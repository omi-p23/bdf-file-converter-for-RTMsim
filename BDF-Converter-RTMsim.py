import meshio
import numpy as np
import sys

# Step 1: Get input and output filenames from the command line
if len(sys.argv) != 3:
    print("\n" + "="*60)
    print("Mesh-to-RTMsim BDF Converter")
    print("="*60)
    print("\nUsage: python convert_to_rtmsim.py <input_file> <output_file.bdf>")
    print("\n<input_file> can be any format meshio supports (e.g., .msh, .stl, .obj, .inp)")
    exit()

input_file = sys.argv[1]
output_file = sys.argv[2]

print(f"Reading mesh data from '{input_file}'...")
try:
    # Meshio automatically detects the file type from the extension and content
    mesh = meshio.read(input_file)
except Exception as e:
    print(f"\nFATAL ERROR: Could not read the input file '{input_file}'.")
    print(f"Meshio error: {e}")
    exit()

# Extract only the triangular elements from the input file
points = mesh.points
triangle_cells = None

try:
    # Meshio stores elements in "cell blocks". We find the block with triangles.
    for cell_block in mesh.cells:
        if cell_block.type == "triangle":
            triangle_cells = cell_block.data
            print(f"  -> Found {len(triangle_cells)} triangle elements in the file.")
            break # Stop after finding the first block of triangles
    
    if triangle_cells is None:
        raise ValueError("No triangular elements were found in the input file. "
                         "RTMsim requires a triangular surface mesh.")

except Exception as e:
    print(f"\nFATAL ERROR: {e}")
    exit()

print(f"Writing {len(points)} nodes and {len(triangle_cells)} triangles to BDF format...")

try:
    with open(output_file, 'w') as f:
        f.write("$ Generated by the RTMsim BDF Converter\n Copyright Omkar Pradhan, 2025")
        f.write("$ Format: Nastran BDF (small-field, high-compatibility)\n")
        f.write("BEGIN BULK\n")
        
        # --- Dummy Properties (Required for BDF validity, ignored by RTMsim) ---
        prop_id = 1
        mat_id = 1
        f.write(f"{'PSHELL':<8}{prop_id:>8}{mat_id:>8}{1.0:>8.1f}\n")
        f.write(f"{'MAT1':<8}{mat_id:>8}{2.1e+5:>8.1e}{'':>8}{0.3:>8.1f}\n")

        # --- Write Nodes (Classic GRID small-field format) ---
        for i, point in enumerate(points):
            node_id = i + 1
            x, y, z = point
            # This line also rounds down the precision to a number that RTMsim can read
            f.write(f"{'GRID':<8}{node_id:>8}{'':>8}{x:>8.4f}{y:>8.4f}{z:>8.4f}\n") 

        # --- Write Triangles (CTRIA3 format) ---
        element_id_counter = 1
        for cell in triangle_cells:
            # Node IDs must be 1-indexed for BDF format
            node1, node2, node3 = cell[0] + 1, cell[1] + 1, cell[2] + 1
            f.write(f"{'CTRIA3':<8}{element_id_counter:>8}{prop_id:>8}{node1:>8}{node2:>8}{node3:>8}\n")
            element_id_counter += 1

        f.write("ENDDATA\n")

    print("\n" + "-"*30)
    print("--- CONVERSION COMPLETE ---")
    print(f"Successfully created: '{output_file}'")
    print("This file should be ready for RTMsim.")
    print("-"*30)

except Exception as e:
    print(f"\nFATAL ERROR: An unexpected error occurred while writing the BDF file.")
    print(f"Error details: {e}")
